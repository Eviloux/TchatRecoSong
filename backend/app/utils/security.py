"""Utility helpers for password hashing and verification."""

from __future__ import annotations

import base64
import hashlib
import hmac
import secrets
from typing import Final


_PBKDF2_ALGORITHM: Final[str] = "pbkdf2_sha256"
_PBKDF2_ITERATIONS: Final[int] = 600_000
_PBKDF2_SALT_BYTES: Final[int] = 16


class InvalidPasswordHash(ValueError):
    """Raised when a stored password hash cannot be interpreted."""


def _b64encode(raw: bytes) -> str:
    return base64.b64encode(raw).decode("ascii")


def _b64decode(data: str) -> bytes:
    try:
        return base64.b64decode(data.encode("ascii"))
    except (ValueError, TypeError) as exc:  # pragma: no cover - defensive guard
        raise InvalidPasswordHash("Encodage base64 invalide") from exc


def hash_password(password: str, *, salt: bytes | None = None) -> str:
    """Hash the given password using PBKDF2-SHA256.

    The returned value follows the format:
        pbkdf2_sha256$<iterations>$<salt_b64>$<hash_b64>
    """

    if not isinstance(password, str):  # pragma: no cover - defensive guard
        raise TypeError("Le mot de passe doit être une chaîne de caractères")

    if salt is None:
        salt = secrets.token_bytes(_PBKDF2_SALT_BYTES)

    derived = hashlib.pbkdf2_hmac(
        "sha256", password.encode("utf-8"), salt, _PBKDF2_ITERATIONS
    )
    return f"{_PBKDF2_ALGORITHM}${_PBKDF2_ITERATIONS}${_b64encode(salt)}${_b64encode(derived)}"


def verify_password(password: str, stored_hash: str) -> bool:
    """Validate *password* against *stored_hash* generated by :func:`hash_password`."""

    try:
        algorithm, iter_str, salt_b64, hash_b64 = stored_hash.split("$")
    except ValueError:
        return False

    if algorithm != _PBKDF2_ALGORITHM:
        return False

    try:
        iterations = int(iter_str)
    except ValueError:
        return False

    try:
        salt = _b64decode(salt_b64)
        expected_hash = _b64decode(hash_b64)
    except InvalidPasswordHash:
        return False

    candidate = hashlib.pbkdf2_hmac(
        "sha256", password.encode("utf-8"), salt, iterations
    )
    return hmac.compare_digest(candidate, expected_hash)


__all__ = ["hash_password", "verify_password", "InvalidPasswordHash"]
