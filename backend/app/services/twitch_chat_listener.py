"""Async listener that watches a Twitch chat channel for ``!reco`` commands.

The Twitch IRC interface is the most direct way to read messages from a Twitch chat
without needing to spin up a full EventSub webhook stack.  This module wraps the
minimal IRC logic required to connect over WebSocket, maintain the connection, and
parse commands of the form ``!reco [comment]``.

Example
-------
>>> import asyncio
>>> from backend.app.services import TwitchChatListener
>>>
>>> async def main():
...     listener = TwitchChatListener(
...         channel="votre_chaine",
...         username="nom_du_bot",
...         oauth_token="oauth:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
...     )
...
...     async for command in listener.watch_commands():
...         print(command.user, command.comment)
...
>>> asyncio.run(main())

The ``oauth_token`` can be generated by creating a Twitch application and running
an OAuth ``Client Credentials`` flow, then exchanging the app access token for a
``chat:read`` user token with the ``https://id.twitch.tv/oauth2/authorize`` flow.
"""

from __future__ import annotations

import asyncio
import logging
import os
import re
from dataclasses import dataclass
from typing import AsyncGenerator, Optional

import websockets
from websockets.client import WebSocketClientProtocol
from websockets.exceptions import ConnectionClosed

LOGGER = logging.getLogger(__name__)

TWITCH_IRC_ENDPOINT = "wss://irc-ws.chat.twitch.tv:443"
COMMAND_PATTERN = re.compile(r"^!reco(?:\\s+(?P<comment>.*))?$", re.IGNORECASE)


@dataclass(slots=True)
class TwitchCommand:
    """Represents a ``!reco`` command sent in the chat."""

    user: str
    comment: str | None


class TwitchChatListener:
    """High-level helper that streams ``!reco`` commands from Twitch chat.

    Parameters
    ----------
    channel:
        The Twitch channel (without the leading ``#``) to join.
    username:
        The username of the account that owns the OAuth token.  Twitch requires
        that ``PASS`` and ``NICK`` match.
    oauth_token:
        The OAuth token with the ``chat:read`` and ``chat:edit`` scopes.  It must
        include the ``oauth:`` prefix returned by Twitch.
    rate_limit_wait:
        Amount of time to wait before attempting to reconnect after a disconnect.
    """

    def __init__(
        self,
        channel: str,
        username: Optional[str] = None,
        oauth_token: Optional[str] = None,
        *,
        rate_limit_wait: float = 5.0,
    ) -> None:
        self.channel = channel.lstrip("#")
        self.username = username or os.environ.get("TWITCH_USERNAME")
        self.oauth_token = oauth_token or os.environ.get("TWITCH_OAUTH_TOKEN")
        self.rate_limit_wait = rate_limit_wait

        if not self.username:
            raise ValueError("Missing Twitch username. Pass it explicitly or set TWITCH_USERNAME.")
        if not self.oauth_token:
            raise ValueError(
                "Missing Twitch OAuth token. Pass it explicitly or set TWITCH_OAUTH_TOKEN."
            )

    async def watch_commands(self) -> AsyncGenerator[TwitchCommand, None]:
        """Yield ``TwitchCommand`` objects as soon as they appear in chat.

        The generator handles ping/pong keep-alives and automatically reconnects
        with a small delay when the socket is closed by Twitch.
        """

        while True:
            try:
                async with websockets.connect(
                    TWITCH_IRC_ENDPOINT,
                    ping_interval=30,
                    ping_timeout=30,
                ) as connection:
                    await self._authenticate(connection)
                    async for command in self._listen_loop(connection):
                        yield command
            except ConnectionClosed as exc:  # pragma: no cover - network dependent
                LOGGER.warning("Twitch IRC connection closed (%s). Reconnecting in %.1fs", exc, self.rate_limit_wait)
                await asyncio.sleep(self.rate_limit_wait)
            except Exception:  # pragma: no cover - safety net
                LOGGER.exception("Unexpected error while listening to Twitch chat")
                await asyncio.sleep(self.rate_limit_wait)

    async def _authenticate(self, connection: WebSocketClientProtocol) -> None:
        await connection.send(f"PASS {self.oauth_token}")
        await connection.send(f"NICK {self.username}")
        await connection.send("CAP REQ :twitch.tv/tags twitch.tv/commands")
        await connection.send(f"JOIN #{self.channel}")

    async def _listen_loop(
        self, connection: WebSocketClientProtocol
    ) -> AsyncGenerator[TwitchCommand, None]:
        async for raw in connection:
            for payload in raw.split("\r\n"):
                if not payload:
                    continue
                if payload.startswith("PING"):
                    await connection.send("PONG :tmi.twitch.tv")
                    continue
                command = self._parse_payload(payload)
                if command:
                    yield command

    def _parse_payload(self, payload: str) -> Optional[TwitchCommand]:
        if " PRIVMSG " not in payload:
            return None
        try:
            prefix, message = payload.split(" PRIVMSG ", 1)
            user_part = prefix.split("!", 1)[0]
            user = user_part.split(":", 1)[-1]
            text = message.split(" :", 1)[-1]
        except ValueError:
            LOGGER.debug("Unable to parse payload: %s", payload)
            return None

        match = COMMAND_PATTERN.match(text.strip())
        if not match:
            return None

        comment = match.group("comment")
        if comment is not None:
            comment = comment.strip()
        return TwitchCommand(user=user, comment=comment or None)
